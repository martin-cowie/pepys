#!/usr/bin/perl
use strict;
use warnings;
use File::Path qw(make_path);

=pod
=head1 Generate Envelope/Header/Body structure for both web service requests & responses.
=cut

use XML::XPath;
use XML::XPath::XMLParser;

die "wrong # args, try $0 input.wsdl output-dir" unless(@ARGV == 2);
my ($filename, $outdir) = @ARGV;

sub generate_requests_enum {
    my @requests = map {
        my $result = <<"FIN";
    #[yaserde(prefix = "tds")]
    $_(super::$_)
FIN
        chomp $result;
        $result
    } sort @_;

    return <<"FIN";
// Generated by $0 from $filename ---------------------
use yaserde_derive::*;
use soapenv::Header;

#[derive(Debug, YaDeserialize)]
#[yaserde(
    prefix = "s",
    namespace = "s: http://www.w3.org/2003/05/soap-envelope",
    namespace = "tds: http://www.onvif.org/ver10/device/wsdl"
)]
pub struct Envelope {
    #[yaserde(prefix = "s", rename = "Header")]
    pub header: Option<Header>,

    #[yaserde(prefix = "s", rename = "Body")]
    pub body: Body,
}

#[derive(Debug, YaDeserialize)]
#[yaserde(
    prefix = "s",
    namespace = "s: http://www.w3.org/2003/05/soap-envelope",
)]
pub enum Body {
    Unknown, // Requirement of `Default` impl, required by YaDeserialize

    ${\( join(",\n\n", @requests ) )}
}

impl Default for Body {
    fn default() -> Self {
        Body::Unknown
    }
}
FIN
}

sub generate_responses_enum {
    my @responses = sort @_;

    return <<"FIN";
// Generated by $0 from $filename ---------------------
use yaserde_derive::*;

#[derive(Debug, YaSerialize, YaDeserialize)]
#[yaserde(
    prefix = "s",
    namespace = "s: http://www.w3.org/2003/05/soap-envelope",
    namespace = "tds: http://www.onvif.org/ver10/device/wsdl"
)]
pub struct Envelope {
    #[yaserde(prefix = "s", rename = "Body")]
    pub body: Body,
}

#[derive(Debug, YaSerialize, YaDeserialize)]
#[yaserde(
    prefix = "s",
    namespace = "s: http://www.w3.org/2003/05/soap-envelope",
)]
pub enum Body {
    Unknown, // Requirement of `Default` impl, required by YaDeserialize

    ${\( join(",\n\t", map {"$_(super::$_)"} @responses) )}
}

impl Default for Body {
    fn default() -> Self {
        Body::Unknown
    }
}

FIN
}

sub save {
    my ($source, $filename) = @_;
    open(FILE, ">", $filename) or die "Cannot write to $filename: $!";
    print FILE $source;
    close(FILE);

    print STDERR "Wrote to $filename\n";
}

# ----------- main -----------

my $xp = XML::XPath->new(filename => $filename);
$xp->set_namespace("wsdl", "http://schemas.xmlsoap.org/wsdl/");

if (make_path($outdir)) {
    print STDERR "Created directory $outdir\n";
}

my $nodeset = $xp->find('//wsdl:portType/wsdl:operation');
my @nodes = $nodeset->get_nodelist;
print STDERR "Found ", scalar @nodes, " nodes in $filename\n";

my (@requests, @responses);
foreach my $node (@nodes) {
    my $inputStructName = $xp->find('string(@name)', $node);
    my $outputNode = $xp->find('string(wsdl:output/@message)', $node);

    die "Cannot parse $outputNode" unless $outputNode =~ /^(\w+):(.+)$/ ;
    my $outputStructName = $2;

    push @requests, $inputStructName;
    push @responses, $outputStructName;
}

my $requestSource = generate_requests_enum(@requests);
my $responseSource = generate_responses_enum(@responses);
save($requestSource, "$outdir/request.rs");
save($responseSource, "$outdir/response.rs");